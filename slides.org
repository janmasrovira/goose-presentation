#+title: AVM in practice
#+author: Jan Mas Rovira \and Åukasz Czajka \and Tobias Heindel
#+date: \today
#+latex_class: beamer

#+latex_class_options: [bigger]
#+options: H:1 toc:nil
#+latex_compiler: xelatex

#+latex_header: \usepackage{booktabs}
#+latex_header: \usepackage[table, x11names]{xcolor}
#+latex_header: \usepackage{fancyvrb}
#+latex_header: \usepackage{twemojis}
#+latex_header: \usepackage{chronos}
#+latex_header: \usepackage{hyperref}

#+latex_header: \hypersetup{colorlinks=true,urlcolor=RoyalBlue3,linkcolor=Salmon4,citecolor=Green4}
#+latex_header: \definecolor{avmcolor}{HTML}{008B45}
#+latex_header: \definecolor{firebrick}{HTML}{B22222}
#+latex_header: \definecolor{codecolor}{HTML}{6A5ACD}

* Init config :noexport:
#+name: init
#+begin_src elisp
(setq org-latex-hyperref-template "")
#+end_src

* How to write Anoma applications?
#+begin_center
*The Anoma Resource Machine*
#+end_center

#+begin_export latex
~
\pause{}
#+end_export

#+begin_quote
The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences.
#+end_quote

#+begin_export latex
~
\pause{}
#+end_export

* Using the ARM directly
Writing an application using the ARM directly involves many new concepts:
1. Resources
2. Resource logics
3. Nonces
4. Actions
7. Delta proofs
5. Compliance units
6. Transactions
7. etc.

#+begin_comment
How many people have written an application in full detail using the ARM layer?
#+end_comment

* How it feels
#+attr_latex: :width \textwidth
[[file:img/knight-text.jpg]]

#+begin_comment
TODO maybe rename you to Developer and ARM to Resource Machine
#+end_comment

* AVM
** We made it easier
by adding an *object oriented programming* layer on top. \pause{}

** Benefits
1. The *OOP* paradigm is already familiar to most of us. \pause{}
2. We don't need to worry about the ARM details. \pause{}
   1. Automatically generated resource *logic functions* with *strong guarantees*. \pause{}
   2. We don't have to generate fresh *nonces* for the resources ourselves. \pause{}
   3. We don't have to worry about creating *ephemeral* resources to balance
      transactions. \pause{}
   4. We don't need to explicitly create *compliance units*.
   5. etc.

* Pipeline
#+begin_src dot :file img/layers1.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    AVM [label="AVM"; color=springgreen4; fontcolor=springgreen4];
    SARM [label="Model ARM"];
    ARM [label="Real ARM"];

    { rank=same; AVM; SARM; ARM }

    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+RESULTS:
[[file:img/layers1.pdf]]

#+attr_latex: :width 1.1\linewidth
[[file:img/layers1.pdf]]

* Pipeline
#+begin_src dot :file img/layers2.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    Concrete [label="Code", style=dashed; color=slateblue; fontcolor=slateblue];
    AVM [label="AVM"; color=springgreen4; fontcolor=springgreen4];
    SARM [label="Model ARM"];
    ARM [label="Real ARM"];

    { rank=same; Concrete; AVM; SARM; ARM }

    Concrete -> AVM [style=dashed; color=slateblue; minlen=2];
    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+attr_latex: :width 1.1\linewidth
[[file:img/layers2.pdf]]

- Examples will be in \textcolor{codecolor}{code} and in the
  \textcolor{avmcolor}{AVM} layer.
- \textcolor{firebrick}{Red} is not yet implemented.

# It needs to be explained why source missing is important!!
# pseudocode in blue instead of Source
# emphasis on not worrying about AVM syntax but the information

#+begin_comment
 The model is in Lean4, so the concrete syntax will be in Lean. What we call the
 AVM layer, it's basically a collection of Lean data types and functions.
#+end_comment

* An example: Counter in \textcolor{codecolor}{code}
#+begin_src kotlin
class Counter {
    private var value: Nat

    constructor(ini: Nat) {
        value = ini
    }

    fun increment(amount: Nat) {
        value += amount
    }
}
#+end_src

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:
** The host language struct
#+begin_export latex
\begin{semiverbatim}\small
structure Counter where
  count : Nat
\end{semiverbatim}
#+end_export

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** The AVM type /signatures/
#+begin_export latex
\begin{semiverbatim}\scriptsize
inductive Constructors where
  | Zero : Constructors
  \pause{}
inductive Methods where
  | Incr : Methods
  \pause{}
def clab : Class.Label where
  name := "UniversalCounter"
  PrivateFields := Nat
  \pause{}
  MethodId := Methods
  MethodArgs id := match id with
    | Methods.Incr => Nat
  \pause{}
  ConstructorId := Constructors
  ConstructorArgs id := match id with
    | Constructors.Zero => Unit
\end{semiverbatim}
#+end_export

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** The implementation of the class members
#+begin_export latex
\begin{semiverbatim}\scriptsize
defConstructor
 (body := fun (_noArgs : Unit) => \{count := 0 : Counter\})

\pause{}
defMethod
 (body := fun (self : Counter) (step : Nat) =>
   [\{self with count := self.count + step : Counter\}])
\end{semiverbatim}
#+end_export

* Counter in  the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** Translate between host struct and AVM Object
#+begin_export latex
\begin{semiverbatim}\scriptsize
def toObject (c : Counter) : Object clab where
  quantity := 1
  privateFields := c.count
\pause{}
def fromObject (o : Object clab) : Option Counter := do
  guard (o.quantity == 1)
  some (Counter.mk o.privateFields)
\end{semiverbatim}
#+end_export
#+begin_export latex
~
\pause{}
#+end_export
We are done!

* Result
** ARM Transactions
1. *New counter* transaction
2. *Increment* transaction

\pause{}

** Safety guarantees
The counter resources can only be updated through their class interface. This is
ensured by the generated resource logic function.

* Yay
\fontsize{150}{0}\selectfont
#+begin_center
\texttwemoji{confetti_ball}
#+end_center

* AVM language
** What can you do with AVM?
1. Define *Classes*.
1. Define *Methods*.
1. Define *Constructors*.
1. Define *Destructors*.
1. Define multi-object *Functions*.

* An example: Kudos Bank
A user can:
1. *Open* a bank. \pause{}
2. *Create tokens* of their own denomination and store them in a bank. \pause{}
3. *Transfer* owned tokens to some other user in the same bank. \pause{}
4. *Issue a check* by substracting a certain amount from a your bank account. \pause{}
5. *Transfer* a check to another user. \pause{}
6. *Deposit* a check into a bank.

* Issuing a check in \textcolor{codecolor}{code}
:properties:
:beamer_opt: fragile
:end:

#+begin_export latex
\begin{semiverbatim}\footnotesize
fun issueCheck(bank: Bank, d: Denom, n: Nat
               , owner: PubId, key: PrivKey) \{
  \alert<2>{assert checkKey(owner, key);}
  \alert<3>{assert n > 0;}
  \alert<4>{assert bank.getBalance(owner, d) >= n;}
  \alert<5>{bank.subtract(owner, d, n);}
  \alert<6>{new Check(owner, d, n);}\alert<7>{}
\}
\end{semiverbatim}
#+end_export

* Issuing a check in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

#+begin_export latex
\begin{semiverbatim}\scriptsize
defFunction lab Functions.IssueCheck
\alert<2>{(argsInfo := fun
  | .bank => \{ type := KudosBank \})}
(body := fun selves args =>
  \{ \alert<3>{created :=
    [(selves .bank).overBalances (fun b => b
      |> Balances.subTokens args.owner
                            args.denomination
                            args.quantity)]}
    \alert<4>{constructed := [{ denomination := args.denomination
                     owner := args.owner
                     quantity := args.quantity
                     : Check }]\})}
(invariant := fun selves args =>
  \alert<5>{checkKey args.owner args.key}
  && \alert<6>{0 < args.quantity}
  && \alert<7>{args.quantity
     <= (selves .bank |>.getBalance args.owner args.denomination))}
     \alert<8>{}
\end{semiverbatim}
#+end_export


* That's all
#+begin_center
That's all for AVM 0.1
#+end_center

#+begin_center
What's next?
#+end_center

* Timeline
#+begin_export latex
\begin{chronos}%
  [
    dates={2025-01-01}:{2026-01-01},
    timeline width=\textwidth,
    timeline height=.1\textheight,
    step major year=1,
    timeline marks=true,
    timeline bare marks=false,
    step divisions=12,
    levels=4:3,
  ]
  \chronoslife{dates={2025-01-01}:{2025-06-01},name=dark age,at=u1 -| dark age,text content=Dark Age}
  \chronoslife{dates={2025-06-01}:{2025-08-15},name=avm01,at=u2 -| avm01,text content=AVM 0.1 (presented)}
  \chronoslife{dates={2025-08-15}:{2025-12-01},name=avm02,at=u1 -| avm02,text content=AVM 0.2 (next)}
  \chronosevent{date={2025-09-08},name=today,at=i1 -| today, text content=Today}
\end{chronos}
#+end_export

* Versions comparison
#+macro: check \texttwemoji{white_check_mark}
#+macro: cross \texttwemoji{x}
#+attr_latex: :booktabs :align l|cc
|                         | AVM 0.1     | AVM 0.2 (next) |
|-------------------------+-------------+----------------|
| Methods                 | {{{check}}} | {{{check}}}    |
| Constructors            | {{{check}}} | {{{check}}}    |
| Destructors             | {{{check}}} | {{{check}}}    |
| Multi-object functions  | {{{check}}} | {{{check}}}    |
| Nested objects          | {{{cross}}} | {{{check}}}    |
| Nested method calls     | {{{cross}}} | {{{check}}}    |
| Multi-call transactions | {{{cross}}} | {{{check}}}    |
| Intents                 | basic       | improved       |
| Surface syntax          | basic       | improved       |

#+begin_export latex
~
\pause{}
#+end_export

** Keep updated at:
#+begin_center
[[https://github.com/anoma/goose-lean][github.com/anoma/goose-lean]]
#+end_center
