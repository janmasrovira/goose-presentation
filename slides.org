#+title: AVM in practice
#+author: Jan Mas Rovira \and Åukasz Czajka \and Tobias Heindel
#+date: \today
#+latex_class: beamer

# #+latex_class_options: [bigger, xcolor={x11names,table}]
#+latex_class_options: [bigger, xcolor={x11names}]
#+options: H:1 toc:nil
#+latex_compiler: xelatex

#+latex_header: \usepackage{fontspec}
#+latex_header: \usepackage{fancyvrb}
#+latex_header: \setmonofont{FreeMono}
#+latex_header: \usepackage{twemojis}
#+latex_header: \usepackage{chronos}
#+latex_header: \usepackage{hyperref}

#+latex_header: \hypersetup{colorlinks=true,urlcolor=RoyalBlue3,linkcolor=Salmon4,citecolor=Green4}

* How to write Anoma applications?
#+begin_center
*The Anoma Resource Machine*
#+end_center

#+begin_export latex
~
\pause{}
#+end_export

#+begin_quote
The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences.
#+end_quote

#+begin_export latex
~
\pause{}
#+end_export

* Using the ARM directly
Writing an application using the ARM directly involves many new concepts:
1. Resources
2. Resource logics
3. Nonces
4. Actions
7. Delta proofs
5. Compliance units
6. Transactions
7. etc.

#+begin_comment
How many people have written an application in full detail using the ARM layer?
#+end_comment

* How it feels
#+attr_latex: :width \textwidth
[[file:img/knight-text.jpg]]

#+begin_comment
TODO maybe rename you to Developer and ARM to Resource Machine
#+end_comment

* AVM
#+begin_comment
We realized we needed to improve the developer experience. Because the resource
machine uses resources for persistance storage and we use transactions to modify
them, it seemed like designing an abstraction layer based on object oriented programming made sense.
#+end_comment

** We made it better
with object oriented programming:
1. Objects
2. Method calls
3. Constructors
4. Functions (multi object methods)
5. Intents


* Pipeline
#+begin_src dot :file img/layers.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    Concrete [label="Source", style=dashed; color=firebrick; fontcolor=firebrick];
    AVM [label="AVM"; color="#5DBB63"; fontcolor="#5DBB63"];
    SARM [label="Simple ARM"];
    ARM [label="Real ARM"];

    { rank=same; Concrete; AVM; SARM; ARM }

    Concrete -> AVM [style=dashed; color=firebrick; minlen=2];
    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+RESULTS:
[[file:img/layers.pdf]]

#+attr_latex: :width 1.1\linewidth
[[file:img/layers.pdf]]

\definecolor{avmcolor}{HTML}{5DBB63}
\definecolor{firebrick}{HTML}{B22222}

- \textcolor{firebrick}{Red} means it is not yet implemented.
- \textcolor{avmcolor}{Examples} will be in the \textcolor{avmcolor}{AVM} layer.

#+begin_comment
 The model is in Lean4, so the concrete syntax will be in Lean. What we call the
 AVM layer, it's basically a collection of Lean data types and functions.
#+end_comment

* An example: Counter
How the =Counter= class would look in a familiar language:
#+begin_src kotlin
class Counter {
    private var value: Nat

    constructor(ini: Nat) {
        value = ini
    }

    fun increment(amount: Nat) {
        value += amount
    }
}
#+end_src

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The host language struct
#+begin_export latex
\begin{semiverbatim}\small
structure Counter where
  count : Nat
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The AVM type /signatures/
#+begin_export latex
\begin{semiverbatim}\scriptsize
inductive Constructors where
  | Zero : Constructors
  \pause{}
inductive Methods where
  | Incr : Methods
  \pause{}
def clab : Class.Label where
  name := "UniversalCounter"
  PrivateFields := Nat
  \pause{}
  MethodId := Methods
  MethodArgs id := match id with
    | Methods.Incr => Nat
  \pause{}
  ConstructorId := Constructors
  ConstructorArgs id := match id with
    | Constructors.Zero => Unit
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The implementation of the class members
#+begin_export latex
\begin{semiverbatim}\scriptsize
defConstructor
 (body := fun (_noArgs : Unit) => \{count := 0 : Counter\})

\pause{}
defMethod
 (body := fun (self : Counter) (step : Nat) =>
   [\{self with count := self.count + step : Counter\}])
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** Translate between host struct and AVM Object
#+begin_export latex
\begin{semiverbatim}\scriptsize
def toObject (c : Counter) : Object clab where
  quantity := 1
  privateFields := c.count
\pause{}
def fromObject (o : Object clab) : Option Counter := do
  guard (o.quantity == 1)
  some (Counter.mk o.privateFields)
\end{semiverbatim}
#+end_export
#+begin_export latex
~
\pause{}
#+end_export
We are done!

* Yay
\fontsize{150}{0}\selectfont
#+begin_center
\texttwemoji{confetti_ball}
#+end_center

* Remarks
1. Yout don't need to be an ARM expert to write an app.

* Timeline
#+begin_export latex
\begin{chronos}%
  [
    dates={2025-01-01}:{2026-01-01},
    timeline width=\textwidth,
    timeline height=.1\textheight,
    step major year=1,
    timeline marks=true,
    timeline bare marks=false,
    step divisions=12,
    levels=4:3,
  ]
  \chronoslife{dates={2025-01-01}:{2025-06-01},name=dark age,at=u1 -| dark age,text content=Dark Age}
  \chronoslife{dates={2025-06-01}:{2025-08-15},name=avm01,at=u2 -| avm01,text content=AVM 0.1 (presented)}
  \chronoslife{dates={2025-08-15}:{2025-12-01},name=avm02,at=u1 -| avm02,text content=AVM 0.2 (next)}
  \chronosevent{date={2025-09-08},name=june,at=i1 -| june,text content=Today}
\end{chronos}
#+end_export

* Keep updated at:
#+begin_center
[[https://github.com/anoma/goose-lean][github.com/anoma/goose-lean]]
#+end_center
