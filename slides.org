#+title: AVM in practice
#+author: Jan Mas Rovira \and Łukasz Czajka \and Tobias Heindel
#+date: \today
#+latex_class: beamer

#+latex_class_options: [bigger]
#+options: H:1 toc:nil
#+latex_compiler: xelatex

#+latex_header: \usepackage{booktabs}
#+latex_header: \usepackage[table, x11names]{xcolor}
#+latex_header: \usepackage{fancyvrb}
#+latex_header: \usepackage{twemojis}
#+latex_header: \usepackage{chronos}
#+latex_header: \usepackage{hyperref}

#+latex_header: \hypersetup{colorlinks=true,urlcolor=RoyalBlue3,linkcolor=Salmon4,citecolor=Green4}
#+latex_header: \definecolor{avmcolor}{HTML}{008B45}
#+latex_header: \definecolor{firebrick}{HTML}{B22222}
#+latex_header: \definecolor{codecolor}{HTML}{6A5ACD}

* Init config :noexport:
#+name: init
#+begin_src elisp
(setq org-latex-hyperref-template "")
#+end_src

* How to write Anoma applications?
#+begin_center
*The Anoma Resource Machine*
#+end_center

#+begin_export latex
~
\pause{}
#+end_export

#+begin_quote
The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences.
#+end_quote

#+begin_export latex
~
\pause{}
#+end_export

#+begin_comment
It's anoma day. So let's write some apps for anoma. If you want to write an app, the main component of the protocol that you'll interact with is the Resource Machine.

#+end_comment
* Using the ARM directly
Writing an application using the ARM directly involves many new concepts:
1. Resources
2. Resource logics
3. Nonces
4. Actions
7. Delta proofs
5. Compliance units
6. Transactions
7. etc.

#+begin_comment
How many people have written an application in full detail using the ARM layer?
How many thought that was easy?

Yeah, I see. The problem is that writing applications directly to the ARM feels
like writing assembly code and you must keep a lot if things in your head. It's
also very easy to mess up the logic functions.
#+end_comment

* How it feels
#+attr_latex: :width \textwidth
[[file:img/knight-text.jpg]]

#+begin_comment
This is how it feels. But we don't want that. We want to keep all the good
things about the ARM and make it easier for developers to write apps for it.
#+end_comment

* AVM
** We made it easier
by adding an *object oriented programming* layer on top. \pause{}

** Benefits
1. The *OOP* paradigm is already familiar to most of us. \pause{}
2. We don't need to worry about the ARM details. \pause{}
   - Automatically generated resource *logic functions* with *strong guarantees*. \pause{}
   - We don't have to generate fresh *nonces* for the resources ourselves.
   - We don't have to worry about creating *ephemeral* resources to balance
     transactions.
   - We don't need to explicitly create *compliance units*.
   - etc.

#+begin_comment
We made it easier by adding an object oriented layer on top of it. Before we
discuss the details, what are the benefits of this?
#+end_comment

* Pipeline
#+begin_src dot :file img/layers0.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    AVM [label="AVM"; color=springgreen4; fontcolor=springgreen4];
    SARM [label="ARM Model"];

    { rank=same; AVM; SARM }

    AVM -> SARM [minlen=2];
}
#+end_src

#+RESULTS:
[[file:img/layers0.pdf]]

#+attr_latex: :width 1.1\linewidth
[[file:img/layers0.pdf]]

* Pipeline
#+begin_src dot :file img/layers1.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    AVM [label="AVM"; color=springgreen4; fontcolor=springgreen4];
    SARM [label="ARM Model"];
    ARM [label="Real ARM"];

    { rank=same; AVM; SARM; ARM }

    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+RESULTS:
[[file:img/layers1.pdf]]

#+attr_latex: :width 1.1\linewidth
[[file:img/layers1.pdf]]

* Full pipeline
#+begin_src dot :file img/layers2.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    Concrete [label="Code", style=dashed; color=slateblue; fontcolor=slateblue];
    AVM [label="AVM"; color=springgreen4; fontcolor=springgreen4];
    SARM [label="ARM Model"];
    ARM [label="Real ARM"];

    { rank=same; Concrete; AVM; SARM; ARM }

    Concrete -> AVM [style=dashed; color=slateblue; minlen=2];
    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+RESULTS:
[[file:img/layers2.pdf]]

#+attr_latex: :width 1.1\linewidth
[[file:img/layers2.pdf]]

Examples will be in:
1. \textcolor{codecolor}{code}, Java-like syntax.
2. \textcolor{avmcolor}{AVM} layer, Lean syntax.

#+begin_comment
The model is in Lean4, so the concrete syntax will be in Lean. What we call the
AVM layer, it's basically a collection of Lean data types and functions.
Formal Model: Written in Lean, so I’ll show some examples directly in Lean syntax.

Pseudocode: I’ll also show code-like examples in a Java/Kotlin-style syntax.

Why two notations?

Lean: The model is built in Lean4.

Pseudocode: For readability and intuition.

We don’t yet have the concrete syntax of the future language. The pseudocode is
just a placeholder for now.
#+end_comment

* An example: Counter in \textcolor{codecolor}{code}
#+begin_src kotlin
class Counter {
    private var value: Nat

    constructor() {
        value = 0
    }

    fun increment(amount: Nat) {
        value += amount
    }
}
#+end_src

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:
** The host language struct
#+begin_export latex
\begin{semiverbatim}\small
structure Counter where
  count : Nat
\end{semiverbatim}
#+end_export

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** The AVM type /signatures/
#+begin_export latex
\begin{semiverbatim}\scriptsize
\alert<1>{def clab : Class.Label where
  name := "UniversalCounter"
  PrivateFields := Nat}

inductive Constructors where
  | \alert<2>{Ini} : Constructors

ConstructorId := Constructors
ConstructorArgs id := match id with
    | Constructors.Ini => \alert<2>{Unit}

inductive Methods where
  | \alert<3>{Increment} : Methods

MethodId := Methods
MethodArgs id := match id with
    | Methods.Increment => \alert<3>{Nat}
\alert<4>{}
\end{semiverbatim}
#+end_export

* Counter in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** The implementation of the class members
#+begin_export latex
\begin{semiverbatim}\scriptsize
\alert<1>{defConstructor
 (body := fun (_noArgs : Unit) => \{count := 0 : Counter\})}

\alert<2>{defMethod
 (body := fun (self : Counter) (step : Nat) =>
   [\{self with count := self.count + step : Counter\}])}
\end{semiverbatim}
#+end_export

* Counter in  the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

** Translate between host struct and AVM Object
#+begin_export latex
\begin{semiverbatim}\footnotesize
\alert<1>{structure Object (label : Class.Label) where
  quantity : Nat
  privateFields : label.PrivateFields}

\alert<2>{def toObject (c : Counter) : Object clab where
  quantity := 1
  privateFields := c.count}

\alert<3>{def fromObject (o : Object clab) : Option Counter := do
  guard (o.quantity == 1)
  some (Counter.mk o.privateFields)}
\end{semiverbatim}
#+end_export
#+begin_export latex
~
\only<4>{That's all! \texttwemoji{confetti_ball}}
#+end_export

* Result
** ARM Transactions
1. *New counter* transaction
2. *Increment* transaction

\pause{}

** Safety guarantees
The counter resources can only be updated through their class interface. This is
ensured by the generated resource logic function.

For instance, it is impossible to subtract from a counter.

* Yay
\fontsize{150}{0}\selectfont
#+begin_center
\texttwemoji{confetti_ball}
#+end_center

* AVM language
** What can you do with AVM?
1. Define *Classes*.
1. Define *Methods*.
1. Define *Constructors*.
1. Define *Destructors*.
1. Define multi-object *Functions*.

* An example: Kudos Bank
A user can:
1. *Open* a bank. \pause{}
2. *Create tokens* of their own denomination and store them in a bank. \pause{}
3. *Transfer* owned tokens to some other user in the same bank. \pause{}
4. *Issue a check* by subtracting a certain amount from a your bank account. \pause{}
5. *Transfer* a check to another user. \pause{}
6. *Deposit* a check into a bank.

* Issuing a check in \textcolor{codecolor}{code}
:properties:
:beamer_opt: fragile
:end:

#+begin_export latex
\begin{semiverbatim}\footnotesize
fun issueCheck(bank: Bank, d: Denom, n: Nat
               , owner: PubId, key: PrivKey) \{
  \alert<2>{assert checkKey(owner, key);}
  \alert<3>{assert n > 0;}
  \alert<4>{assert bank.getBalance(owner, d) >= n;}
  \alert<5>{bank.subtract(owner, d, n);}
  \alert<6>{new Check(owner, d, n);}\alert<7>{}
\}
\end{semiverbatim}
#+end_export

* Issuing a check in the \textcolor{avmcolor}{AVM layer}
:properties:
:beamer_opt: fragile
:end:

#+begin_export latex
\begin{semiverbatim}\scriptsize
defFunction lab Functions.IssueCheck
 \alert<2>{(argsInfo := fun
   | .bank => \{ type := KudosBank \})}
 (invariant := fun selves args =>
   \alert<3>{checkKey args.owner args.key}
   && \alert<4>{0 < args.quantity}
   && \alert<5>{args.quantity
      <= (selves .bank |>.getBalance args.owner args.denomination))}
 (body := fun selves args =>
   \{ \alert<6>{updated :=
     [(selves .bank).overBalances (fun b => b
       |> Balances.subTokens args.owner
                             args.denomination
                             args.quantity)]}
     \alert<7>{constructed := [{ denomination := args.denomination
                      owner := args.owner
                      quantity := args.quantity
                      : Check }]\})}
      \alert<8>{}
\end{semiverbatim}
#+end_export

* Summary
#+begin_center
That's all for AVM 0.1
#+end_center
** What we achieved
1. A *nice object oriented layer* that abstracts the intricacies of the Anoma
   Resource Machine. \pause{}
2. *100x speedup* in application development time. \pause{}
3. Strong *safety guarantees* ensured by the resource logics. \pause{}
4. Ready for *designing Anoma apps*. \pause{}
5. The prototype itself is implemented in Lean, but it can be easily translated
   into any language. E.g. Rust.

#+begin_export latex
~
\pause{}
#+end_export
** What's next?

* Timeline
#+begin_export latex
\begin{chronos}%
  [
    dates={2025-01-01}:{2026-01-01},
    timeline width=\textwidth,
    timeline height=.1\textheight,
    step major year=1,
    timeline marks=true,
    timeline bare marks=false,
    step divisions=12,
    levels=4:3,
  ]
  \chronoslife{dates={2025-01-01}:{2025-06-01},name=dark age,at=u1 -| dark age,text content=Dark Age}
  \chronoslife{dates={2025-06-01}:{2025-08-15},name=avm01,at=u2 -| avm01,text content=AVM 0.1 (presented)}
  \chronoslife{dates={2025-08-15}:{2025-12-01},name=avm02,at=u1 -| avm02,text content=AVM 0.2 (next)}
  \chronosevent{date={2025-09-08},name=today,at=i1 -| today, text content=Today}
\end{chronos}
#+end_export

* Versions comparison
#+macro: check \texttwemoji{white_check_mark}
#+macro: cross \texttwemoji{x}
#+attr_latex: :booktabs :align l|cc
|                         | AVM 0.1     | AVM 0.2 (next) |
|-------------------------+-------------+----------------|
| Methods                 | {{{check}}} | {{{check}}}    |
| Constructors            | {{{check}}} | {{{check}}}    |
| Destructors             | {{{check}}} | {{{check}}}    |
| Multi-object functions  | {{{check}}} | {{{check}}}    |
| Nested objects          | {{{cross}}} | {{{check}}}    |
| Nested method calls     | {{{cross}}} | {{{check}}}    |
| Multi-call transactions | {{{cross}}} | {{{check}}}    |
| Intents                 | basic       | improved       |
| Surface syntax          | basic       | improved       |

#+begin_export latex
~
\pause{}
#+end_export

** Keep updated at:
#+begin_center
[[https://github.com/anoma/goose-lean][github.com/anoma/goose-lean]]
#+end_center

#+begin_comment
Closing thoughts:
Let me wrap up with a few final thoughts:
I'm personally very excited about this project because despite
being very young it has already shown to be very useful. Before, it would take
multiple days to write an app and it was hard to get everything right. Now it
takes a couple of hours. So I hope you are excited too, Thank you.
#+end_comment

* The end
#+begin_center
Thank you!
#+end_center
