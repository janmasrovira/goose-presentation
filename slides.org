#+title: AVM in practice
#+author: Jan Mas Rovira \and Łukasz Czajka \and Tobias Heindel
#+date: \today
#+latex_class: beamer

#+latex_class_options: [bigger]
#+options: H:1 toc:nil
#+latex_compiler: xelatex

#+latex_header: \usepackage{fontspec}
#+latex_header: \usepackage{booktabs}
#+latex_header: \usepackage[table, x11names]{xcolor}
#+latex_header: \usepackage{fancyvrb}
#+latex_header: \usepackage{twemojis}
#+latex_header: \usepackage{chronos}
#+latex_header: \usepackage{hyperref}

#+latex_header: \setmonofont{FreeMono}
#+latex_header: \hypersetup{colorlinks=true,urlcolor=RoyalBlue3,linkcolor=Salmon4,citecolor=Green4}

* Init config :noexport:
#+name: init
#+begin_src elisp
(setq org-latex-hyperref-template "")
#+end_src

* How to write Anoma applications?
#+begin_center
*The Anoma Resource Machine*
#+end_center

#+begin_export latex
~
\pause{}
#+end_export

#+begin_quote
The Anoma Resource Machine (ARM) is the part of the Anoma protocol that defines and enforces the rules for valid state updates that satisfy users' preferences.
#+end_quote

#+begin_export latex
~
\pause{}
#+end_export

* Using the ARM directly
Writing an application using the ARM directly involves many new concepts:
1. Resources
2. Resource logics
3. Nonces
4. Actions
7. Delta proofs
5. Compliance units
6. Transactions
7. etc.

#+begin_comment
How many people have written an application in full detail using the ARM layer?
#+end_comment

* How it feels
#+attr_latex: :width \textwidth
[[file:img/knight-text.jpg]]

#+begin_comment
TODO maybe rename you to Developer and ARM to Resource Machine
#+end_comment

* AVM
#+begin_comment
We realized we needed to improve the developer experience. Because the resource
machine uses resources for persistance storage and we use transactions to modify
them, it seemed like designing an abstraction layer based on object oriented programming made sense.
#+end_comment

** We made it better
with object oriented programming:
1. Objects
2. Method calls
3. Constructors
4. Functions (multi object methods)
5. Intents


* Pipeline
#+begin_src dot :file img/layers.pdf :cmdline -Tpdf :exports none
digraph G {
    node [shape=box];

    Concrete [label="Source", style=dashed; color=firebrick; fontcolor=firebrick];
    AVM [label="AVM"; color="#5DBB63"; fontcolor="#5DBB63"];
    SARM [label="Simple ARM"];
    ARM [label="Real ARM"];

    { rank=same; Concrete; AVM; SARM; ARM }

    Concrete -> AVM [style=dashed; color=firebrick; minlen=2];
    AVM -> SARM [minlen=2];
    SARM -> ARM [style=dashed; color=firebrick; minlen=2];
}
#+end_src

#+RESULTS:

#+attr_latex: :width 1.1\linewidth
[[file:img/layers.pdf]]

\definecolor{avmcolor}{HTML}{5DBB63}
\definecolor{firebrick}{HTML}{B22222}

- \textcolor{firebrick}{Red} means it is not yet implemented.
- \textcolor{avmcolor}{Examples} will be in the \textcolor{avmcolor}{AVM} layer.

#+begin_comment
 The model is in Lean4, so the concrete syntax will be in Lean. What we call the
 AVM layer, it's basically a collection of Lean data types and functions.
#+end_comment

* An example: Counter
How the =Counter= class would look in a familiar language:
#+begin_src kotlin
class Counter {
    private var value: Nat

    constructor(ini: Nat) {
        value = ini
    }

    fun increment(amount: Nat) {
        value += amount
    }
}
#+end_src

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The host language struct
#+begin_export latex
\begin{semiverbatim}\small
structure Counter where
  count : Nat
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The AVM type /signatures/
#+begin_export latex
\begin{semiverbatim}\scriptsize
inductive Constructors where
  | Zero : Constructors
  \pause{}
inductive Methods where
  | Incr : Methods
  \pause{}
def clab : Class.Label where
  name := "UniversalCounter"
  PrivateFields := Nat
  \pause{}
  MethodId := Methods
  MethodArgs id := match id with
    | Methods.Incr => Nat
  \pause{}
  ConstructorId := Constructors
  ConstructorArgs id := match id with
    | Constructors.Zero => Unit
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** The implementation of the class members
#+begin_export latex
\begin{semiverbatim}\scriptsize
defConstructor
 (body := fun (_noArgs : Unit) => \{count := 0 : Counter\})

\pause{}
defMethod
 (body := fun (self : Counter) (step : Nat) =>
   [\{self with count := self.count + step : Counter\}])
\end{semiverbatim}
#+end_export

* Counter in AVM
:properties:
:beamer_opt: fragile
:end:

** Translate between host struct and AVM Object
#+begin_export latex
\begin{semiverbatim}\scriptsize
def toObject (c : Counter) : Object clab where
  quantity := 1
  privateFields := c.count
\pause{}
def fromObject (o : Object clab) : Option Counter := do
  guard (o.quantity == 1)
  some (Counter.mk o.privateFields)
\end{semiverbatim}
#+end_export
#+begin_export latex
~
\pause{}
#+end_export
We are done!

* Yay
\fontsize{150}{0}\selectfont
#+begin_center
\texttwemoji{confetti_ball}
#+end_center

* Remarks
** Result
1. *New counter* transaction
1. *Increment* transaction

\pause{}
** Benefits
1. Automatically generated resource *logic functions* with *strong guarantees*.
2. We don't have to generate fresh *nonces* for the resources ourselves.
3. We don't have to worry about creating *ephemeral* resources to balance
   transactions.
4. We don't need to explicitly create *compliance units*.
5. The *OOP* paradigm is already familiar to most of us.

* AVM overview
** What can you do with AVM?
1. Define *Objects*.
1. Define *Methods*.
1. Define *Constructors*.
1. Define *Destructors*.
1. Define multi-object *Functions*.

* An example: Kudos Bank
A user can:
1. *Open* a bank.
2. *Create tokens* of their own denomination and store them in a bank.
3. *Transfer* owned tokens to some other user in the same bank.\pause{}
4. *Issue a check* by substracting a certain amount from a your bank account.
5. *Transfer* a check to another user.
6. *Deposit* a check into a bank.

* Issuing a check
:properties:
:beamer_opt: fragile
:end:

#+begin_export latex
\begin{semiverbatim}\scriptsize
defFunction lab Functions.IssueCheck
\alert<2>{(argsInfo := fun
  | .bank => \{ type := KudosBank \})}
(body := fun selves args =>
  \{ \alert<3>{created :=
    [(selves .bank).overBalances (fun b => b
      |> Balances.subTokens args.owner
                            args.denomination
                            args.quantity)]}
    \alert<4>{constructed := [{ denomination := args.denomination
                     owner := args.owner
                     quantity := args.quantity
                     : Check }]\})}
(invariant := fun selves args =>
  \alert<5>{checkKey args.owner args.key}
  && \alert<6>{0 < args.quantity}
  && \alert<7>{args.quantity
     <= (selves .bank |>.getBalance args.owner args.denomination))}
\end{semiverbatim}
#+end_export

* Timeline
#+begin_export latex
\begin{chronos}%
  [
    dates={2025-01-01}:{2026-01-01},
    timeline width=\textwidth,
    timeline height=.1\textheight,
    step major year=1,
    timeline marks=true,
    timeline bare marks=false,
    step divisions=12,
    levels=4:3,
  ]
  \chronoslife{dates={2025-01-01}:{2025-06-01},name=dark age,at=u1 -| dark age,text content=Dark Age}
  \chronoslife{dates={2025-06-01}:{2025-08-15},name=avm01,at=u2 -| avm01,text content=AVM 0.1 (presented)}
  \chronoslife{dates={2025-08-15}:{2025-12-01},name=avm02,at=u1 -| avm02,text content=AVM 0.2 (next)}
  \chronosevent{date={2025-09-08},name=today,at=i1 -| today, text content=Today}
\end{chronos}
#+end_export

* Versions
#+macro: yes \texttwemoji{white_check_mark}
#+macro: no \texttwemoji{x}
#+attr_latex: :booktabs :align l|cc
|                         | AVM 0.1   | AVM 0.2 (next) |
|-------------------------+-----------+----------------|
| Methods                 | {{{yes}}} | {{{yes}}}      |
| Constructors            | {{{yes}}} | {{{yes}}}      |
| Destructors             | {{{yes}}} | {{{yes}}}      |
| Multi-object functions  | {{{yes}}} | {{{yes}}}      |
| Nested objects          | {{{no}}}  | {{{yes}}}      |
| Nested method calls     | {{{no}}}  | {{{yes}}}      |
| Multi-call transactions | {{{no}}}  | {{{yes}}}      |

#+begin_export latex
~
\pause{}
#+end_export

** Keep updated at:
#+begin_center
[[https://github.com/anoma/goose-lean][github.com/anoma/goose-lean]]
#+end_center
